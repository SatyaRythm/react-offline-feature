/* eslint-disable no-restricted-globals */
/* eslint-disable no-undef */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

// Import workbox core
importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.5.4/workbox-sw.js');

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
// This comment is needed for create-react-app's build process:
// eslint-disable-next-line no-unused-expressions
self.__WB_MANIFEST;

const { registerRoute, NavigationRoute, Route } = workbox.routing;
const { StaleWhileRevalidate, NetworkFirst, CacheFirst, NetworkOnly } = workbox.strategies;
const { CacheableResponsePlugin } = workbox.cacheableResponse;
const { ExpirationPlugin } = workbox.expiration;
const { precacheAndRoute, precacheFallback } = workbox.precaching;
const { BackgroundSyncPlugin } = workbox.backgroundSync;
const { clientsClaim } = workbox.core;
const { setCatchHandler } = workbox.routing;

// Claim clients immediately
self.skipWaiting();
clientsClaim();

// Add essential files to precache - these are the app shell
const additionalManifest = [
  { url: '/manifest.json', revision: '1' },
  { url: '/index.html', revision: '1' },
  { url: '/', revision: '1' }
];

// Precache manifest
precacheAndRoute([...(self.__WB_MANIFEST || []), ...additionalManifest]);

// Install event - ensure critical app resources are cached
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('app-shell').then((cache) => {
      return cache.addAll([
        '/',
        '/index.html',
        '/manifest.json',
        '/static/js/bundle.js', // Add the critical JS bundle
        '/static/js/main.chunk.js',
        '/static/js/vendors~main.chunk.js'
      ]);
    })
  );
});

// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy.
registerRoute(
  ({url}) => url.origin === 'https://fonts.googleapis.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
  })
);

// Cache the underlying font files with a cache-first strategy for 1 year.
registerRoute(
  ({url}) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 365,
        maxEntries: 30,
      }),
    ],
  })
);

// Cache static assets (JS, CSS, images) with StaleWhileRevalidate
registerRoute(
  ({ request, url }) => {
    const isStaticAsset = 
      request.destination === 'script' || 
      request.destination === 'style' || 
      request.destination === 'image' ||
      url.pathname.endsWith('.js') ||
      url.pathname.endsWith('.css') ||
      url.pathname.includes('/static/');
    
    return isStaticAsset;
  },
  new StaleWhileRevalidate({
    cacheName: 'static-assets',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 24 * 60 * 60 // 1 day
      }),
    ],
  })
);

// Setup queue for background syncing
const accountSyncPlugin = new BackgroundSyncPlugin('accountSync', {
  maxRetentionTime: 24 * 60, // Retry for max of 24 Hours (specified in minutes)
});

const contactSyncPlugin = new BackgroundSyncPlugin('contactSync', {
  maxRetentionTime: 24 * 60, // Retry for max of 24 Hours (specified in minutes)
});

// Set up API routes handling for accounts and contacts
const apiMatch = ({ url }) => {
  return (
    url.pathname.startsWith('/api/accounts') || 
    url.pathname.startsWith('/api/contacts')
  );
};

// Is this a local data request? If so, bypass cache
const isLocalDataRequest = ({ url, request }) => {
  // Check URL parameters or headers that might indicate local data
  const urlParams = new URL(url).searchParams;
  return urlParams.has('local') || 
         request.headers.get('x-local-data') === 'true' ||
         url.pathname.includes('/accounts/local_') ||
         url.pathname.includes('/contacts/local_');
};

// Handle GET requests with NetworkFirst strategy
registerRoute(
  ({ url, request }) => {
    // Only use this route for API GET requests that aren't local data requests
    return apiMatch({ url }) && 
           request.method === 'GET' && 
           !isLocalDataRequest({ url, request });
  },
  new NetworkFirst({
    cacheName: 'api-responses',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  })
);

// For local data requests, bypass cache completely
registerRoute(
  ({ url, request }) => {
    return apiMatch({ url }) && isLocalDataRequest({ url, request });
  },
  new NetworkOnly() // Force network request, bypassing cache
);

// Handle POST, PUT, DELETE with Background Sync
registerRoute(
  ({ url, request }) => 
    url.pathname.startsWith('/api/accounts') && 
    (request.method === 'POST' || request.method === 'PUT' || request.method === 'DELETE'),
  new NetworkFirst({
    plugins: [accountSyncPlugin],
  })
);

registerRoute(
  ({ url, request }) => 
    url.pathname.startsWith('/api/contacts') && 
    (request.method === 'POST' || request.method === 'PUT' || request.method === 'DELETE'),
  new NetworkFirst({
    plugins: [contactSyncPlugin],
  })
);

// Handle all navigation requests with a NetworkFirst strategy
// This allows the app to work offline with the same UI as online
registerRoute(
  ({ request }) => request.mode === 'navigate',
  new NetworkFirst({
    cacheName: 'pages-cache',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
  
  if (event.data && event.data.type === 'CLIENTS_CLAIM') {
    // This will force the service worker to take control of all clients immediately
    clientsClaim();
  }
});

// Listen for connectivity changes
self.addEventListener('sync', (event) => {
  if (event.tag === 'accountSync' || event.tag === 'contactSync') {
    event.waitUntil(syncData());
  }
});

// Dummy syncData function - the actual sync will be managed by our indexedDB layer
async function syncData() {
  // The actual sync happens in the app code
  // This is just a placeholder for the service worker
  console.log('Background sync triggered');
  return Promise.resolve();
} 